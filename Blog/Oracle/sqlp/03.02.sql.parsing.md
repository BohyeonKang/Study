#3과목 SQL 고급 활용 및 Tuning

##1장 Architecture 기반 Tuning

###1.2 SQL Parsing

####SQL Parsing 과정

1. 사용자 입력 SQL
2. Semantic 검사 : 문법적 오류, 객체 존재 여부
3. Library Cache에서 검색 : Hash구조로 관리. SQL의 Hash값의 Bucket을 찾아봄
  - Soft Parsing : Cache에서 찾아서 바로 실행단계로 넘어감
  - Hard Parsing : Cache에서 찾지 못해서 최적화 과정을 거치고 실행단계로 넘어감
4. 찾지 못했을 경우 최적화 수행
5. 최적화 결과를 Library Cache의 Hash Bucket chain에 연결
6. 해당 Execution Plan을 실행

* Optimizer : 사용자 SQL을 가장 빠르고 효율적인 처리경로를 선택해 주는 DBMS의 핵심엔진

####Caching 된 SQL 공유

* 공유조건 : 그냥 무조건 같은 SQL문이어야 한다.
  1. 공백, 줄바꿈이 다른 경우 : X
  2. 대소문자가 다른 경우 : X
  3. 주석이 다른 경우 : X
  4. OWNER명시 여부 (EMP 와 SCOTT.EMP) : X
  5. Optimizer Hint 여부 : X
  6. WHERE 절의 literal값이 다른 경우 : X

솔직히 1 ~ 5는 각 부서별 SQL표준을 정하면 되는데 6의 경우에는 Bind Variable을 사용할 수 밖에 없다.  
Bind Variable을 사용하면 그만큰 SQL 재사용율이 좋아진다.  
하지만 Bind Variable을 사용하면 실행계획 생성시 통계정보를 활용하지 못한다.  
(당연한 얘기다. 어떤 값이 들어올지 모르기 때문에 그냥 균등하다고 생각하고 실행계획을 작성한다.)  

* Bind Variable을 사용하지 않는게 좋은 경우
  1. DW, OLAP 환경에서의 Long Running Query : Parsing 소유시간에 비해 Execution 시간이 훨씬 길며, Parsing도 자주 일어나지 않는다.
  2. WHERE절의 칼럼 Distinct 값이 적을 경우 : 그만큼 분포가 균일하지 않기 때문에 Histogram을 활용하는게 유리하다.

* Bind Variable Peeking (Sniffing)
  - SQL이 처음 실행될때 Bind Variable 값을 살짝 훔쳐보고 Execution Plan을 작성
  - 뒤에 어떻게 분포가 바뀔지 모르므로 상당히 위험한 기능
  - 왠만해서는 해당 기능을 비활성화 하는게 좋음
```SQL
ALTER SYSTEM SET "_optim_peek_user_binds" = FALSE;
```

####Static SQL, Dynamic SQL

* Static SQL : code 사이에 SQL문을 직접 기술 (Pro*C, Power Builder, SQLJ 등... ). Compile 단계에서 SQL 구문체크가 가능
* Dynamic SQL : String 타입 변수에 SQL문을 저장 (현재 대부분의 경우)

* Application Cursor Caching
  - SQL문을 한번 Parsing한 후 Bind Variable 값만 바꿔가면서 반복적으로 수행
  - Java에서 `.setImplicitCachingEnabled(true)`로 한다던지 Statement를 닫지 않고 재사용하는 방법
  - Parse Call 한번에 Execute Call이 여러번 일어남 (일반적인 경우는 Parse, Execute Call의 수가 같음)

