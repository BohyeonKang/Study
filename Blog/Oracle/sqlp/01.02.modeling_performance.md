##제 1장 데이터 모델링의 이해

- 10문제
- 외우기 보다는 반복적으로 읽어서 전반적인 내용을 이해하는 수준에서 마무리 하는것을 목표로 잡아야 겠습니다.

#제 2장 데이터 모델과 성능

##1절 성능 데이터 모델링의 개요

- 성능 데이터 모델링이란 ? 성능향상을 목적으로 모델링 하는 것
- 수행시점은 ? 빠르면 빠를수록 좋다. 분석/설계 단계에서는 운영때보다 더 적은 비용으로 가능하다.

###성능 모델링 고려사항

1. 기본적으로 정규화를 수행해놓고 시작한다.
2. 데이터베이스 용량산정
3. 데이터베이스 트랜잭션 유형 파악
4. 용량과 트랜잭션 유형에 따라 반정규화 수행
5. 이력모델의 조정, PK/FK 조정, 슈퍼타입/서브타입 조정
6. 성능관점의 데이터 모델 검증

일단 정규화를 완벽하게 해놓고 시작해야 한다.  
그 상태에서 어느 엔터티에 트랜잭션이 들어오는지 알아봐야 하는데,  
가장 간단한 방법이 용량이 집중적으로 늘어나는 엔터티를 찾는 것이다.  
트랜잭션 유형도 파악할 필요가 있는데, CRUD, 시퀀스 다이어그램 등을 참조하면 된다.  
파악된 트랜잭션 유형으로 SQL문장의 조인관계 테이블의 칼럼들을 파악할 수 있으며,  
이렇게 모은 자료를 근거로 반정규화를 적용한다.  
그 다음에 성능을 고려하야 PK/FK를 성능이 우수한 순서대로 칼럼 순서를 조정한다.  
데이터 모델 규칙보다는 성능적인 측면을 충분히 고려해야 한다.

##2절 정규화와 성능

일반적으로 정규화를 하면 조회시 JOIN이 늘어나기 때문에 성능이 저하되고,  
DML (INSERT, UPDATE, DELETE) 연산의 성능이 향상된다.  
하지만 모든 조회에서 성능이 저하되는 것은 아니고, 정규화를 해야만 성능이 향상되는 경우도 아주 많다.  

#####정규화가 더 빠른 사례 1 : 컬럼이 많을 경우 (버퍼 낭비)

원래 (반정규화된) 테이블에는 컬럼이 10개가 있었다.  
조회시 해당 테이블에서 PK를 제외하고 2개의 컬럼만 자주 읽힌다.
오랜기간 동안의 이력중 PK 포함 그 3개의 컬럼만 자주 읽을 경우라면,
나머지 컬럼들을 PK값에 종속적인 테이블로 따로 분리를 하는 것이 유리하다.

#####정규화가 더 빠른 사례 2 : DISTINCT를 써야 할 경우

- 일자별 거래물건 (100만건) : 물건번호(PK), 일자, 시간, 장소, ...
- 일자별 거래내역 (2만건) : (일자, 장소) (PK) 금액, 건수, ...

광화문에서 거래된 금액을 구하는 SQL문은 다음과 같다.

```SQL
SELECT B.금액
  FROM (SELECT DISTINCT 일자, 장소 FROM 일자별거래물건 WHERE 장소 = '광화문`) A, -- 100만건을 DISTINCT
       일자별거래내역 B
 WHERE A.일자 = B.일자
   AND A.장소 = B.장소
```

만약 위에서 DISTICT 한 결과가 5천건이라면, (일자, 장소) 를 별도의 테이블로 생성하는 것이 유리하다.

- 일자별 거래물건 (100만건) : 물건번호(PK), 일자(FK), ...
- 거래 (5천건) : 일자(PK), 시간, 장소
- 일자별 거래내역 (2만건) : (일자(FK), 장소) (PK) , 금액, 건수, ...

```SQL
SELECT B.금액
  FROM 거래 A, 일자별거래내역 B
 WHERE A.장소 = '광화문' -- 5천건
   AND A.일자 = B.일자
   AND A.장소 = B.장소
```

#####정규화가 더 빠른 사례 3 : 동일한 속성 형식이 여러개 나열된 경우

한 테이블에 속성1, 속성2, 속성3, ... 이 여러개 있고, 각각에 INDEX가 걸려 있는 경우를 말한다.  
이런 경우 DML 작업에서의 성능저하 때문에 INDEX를 두지 않거나, 1개 정도만 만드는 경우가 많다.  
각 속성에 부합하는 데이터를 찾는 SQL문은 다음과 같다.

```SQL
SELECT ...
  FROM 장비
 WHERE 속성1 = '1'
    OR 속성2 = '2'
    OR 속성3 = '3'
   ...
```

각각의 속성에 모두 INDEX를 걸어둔 경우가 아니라면 Full Scan이나 Index Range Scan으로 넓은 범위를 찾아야 한다.

위 Table을 아래와 같이 먼저 정규화를 수행한다.

- 장비 : 장비코드(PK), ... (속성들은 모두 제외)
- 속성 : (장비코드(FK), 속성코드) (PK), 속성값

위 상태에서는 속성 테이블에 PK로 인하여 INDEX가 생성되어 있으므로 조회시 성능이 향상된다.
조회는 다음과 같이 수행하면 된다.
```SQL
SELECT ...
  FROM 장비 A, 속성 B
 WHERE A.장비코드 = B.장비코드
   AND (   (B.속성코드 = '1' AND B.속성값 = '1')
        OR (B.속성코드 = '2' AND B.속성값 = '2')
        OR (B.속성코드 = '3' AND B.속성값 = '3') )
```

위와 같이 속성1, 2, 3 뿐만 아니라 이력 같은 데이터를 함께 보관하면서  
장기재고 1개월 수량,금액 , 2개월 수량,금액 , 3개월 수량,금액 과 같은 형식의 컬럼이 있는경우  
재고기간 별 수량,금액 을 별도 테이블로 분리하는 것이 유리하다.

##3절 반정규화와 성능
