#1과목 데이터 모델링의 이해

- 10문제
- 외우기 보다는 반복적으로 읽어서 전반적인 내용을 이해하는 수준에서 마무리 하는것을 목표로 잡아야 겠습니다.

##제 2장 데이터 모델과 성능

###1절 성능 데이터 모델링의 개요

- 성능 데이터 모델링이란 ? 성능향상을 목적으로 모델링 하는 것
- 수행시점은 ? 빠르면 빠를수록 좋다. 분석/설계 단계에서는 운영때보다 더 적은 비용으로 가능하다.

####성능 모델링 고려사항

1. 기본적으로 정규화를 수행해놓고 시작한다.
2. 데이터베이스 용량산정
3. 데이터베이스 트랜잭션 유형 파악
4. 용량과 트랜잭션 유형에 따라 반정규화 수행
5. 이력모델의 조정, PK/FK 조정, 슈퍼타입/서브타입 조정
6. 성능관점의 데이터 모델 검증

일단 정규화를 완벽하게 해놓고 시작해야 한다.  
그 상태에서 어느 엔터티에 트랜잭션이 들어오는지 알아봐야 하는데,  
가장 간단한 방법이 용량이 집중적으로 늘어나는 엔터티를 찾는 것이다.  
트랜잭션 유형도 파악할 필요가 있는데, CRUD, 시퀀스 다이어그램 등을 참조하면 된다.  
파악된 트랜잭션 유형으로 SQL문장의 조인관계 테이블의 칼럼들을 파악할 수 있으며,  
이렇게 모은 자료를 근거로 반정규화를 적용한다.  
그 다음에 성능을 고려하야 PK/FK를 성능이 우수한 순서대로 칼럼 순서를 조정한다.  
데이터 모델 규칙보다는 성능적인 측면을 충분히 고려해야 한다.

###2절 정규화와 성능

일반적으로 정규화를 하면 조회시 JOIN이 늘어나기 때문에 성능이 저하되고,  
DML (INSERT, UPDATE, DELETE) 연산의 성능이 향상된다.  
하지만 모든 조회에서 성능이 저하되는 것은 아니고, 정규화를 해야만 성능이 향상되는 경우도 아주 많다.  

#####정규화가 더 빠른 사례 1 : 컬럼이 많을 경우 (버퍼 낭비)

원래 (반정규화된) 테이블에는 컬럼이 10개가 있었다.  
조회시 해당 테이블에서 PK를 제외하고 2개의 컬럼만 자주 읽힌다.
오랜기간 동안의 이력중 PK 포함 그 3개의 컬럼만 자주 읽을 경우라면,
나머지 컬럼들을 PK값에 종속적인 테이블로 따로 분리를 하는 것이 유리하다.

#####정규화가 더 빠른 사례 2 : DISTINCT를 써야 할 경우

- 일자별 거래물건 (100만건) : 물건번호(PK), 일자, 시간, 장소, ...
- 일자별 거래내역 (2만건) : (일자, 장소) (PK) 금액, 건수, ...

광화문에서 거래된 금액을 구하는 SQL문은 다음과 같다.

```SQL
SELECT B.금액
  FROM (SELECT DISTINCT 일자, 장소 FROM 일자별거래물건 WHERE 장소 = '광화문`) A, -- 100만건을 DISTINCT
       일자별거래내역 B
 WHERE A.일자 = B.일자
   AND A.장소 = B.장소
```

만약 위에서 DISTICT 한 결과가 5천건이라면, (일자, 장소) 를 별도의 테이블로 생성하는 것이 유리하다.

- 일자별 거래물건 (100만건) : 물건번호(PK), 일자(FK), ...
- 거래 (5천건) : 일자(PK), 시간, 장소
- 일자별 거래내역 (2만건) : (일자(FK), 장소) (PK) , 금액, 건수, ...

```SQL
SELECT B.금액
  FROM 거래 A, 일자별거래내역 B
 WHERE A.장소 = '광화문' -- 5천건
   AND A.일자 = B.일자
   AND A.장소 = B.장소
```

#####정규화가 더 빠른 사례 3 : 동일한 속성 형식이 여러개 나열된 경우

한 테이블에 속성1, 속성2, 속성3, ... 이 여러개 있고, 각각에 INDEX가 걸려 있는 경우를 말한다.  
이런 경우 DML 작업에서의 성능저하 때문에 INDEX를 두지 않거나, 1개 정도만 만드는 경우가 많다.  
각 속성에 부합하는 데이터를 찾는 SQL문은 다음과 같다.

```SQL
SELECT ...
  FROM 장비
 WHERE 속성1 = '1'
    OR 속성2 = '2'
    OR 속성3 = '3'
   ...
```

각각의 속성에 모두 INDEX를 걸어둔 경우가 아니라면 Full Scan이나 Index Range Scan으로 넓은 범위를 찾아야 한다.

위 Table을 아래와 같이 먼저 정규화를 수행한다.

- 장비 : 장비코드(PK), ... (속성들은 모두 제외)
- 속성 : (장비코드(FK), 속성코드) (PK), 속성값

위 상태에서는 속성 테이블에 PK로 인하여 INDEX가 생성되어 있으므로 조회시 성능이 향상된다.
조회는 다음과 같이 수행하면 된다.
```SQL
SELECT ...
  FROM 장비 A, 속성 B
 WHERE A.장비코드 = B.장비코드
   AND (   (B.속성코드 = '1' AND B.속성값 = '1')
        OR (B.속성코드 = '2' AND B.속성값 = '2')
        OR (B.속성코드 = '3' AND B.속성값 = '3') )
```

위와 같이 속성1, 2, 3 뿐만 아니라 이력 같은 데이터를 함께 보관하면서  
장기재고 1개월 수량,금액 , 2개월 수량,금액 , 3개월 수량,금액 과 같은 형식의 컬럼이 있는경우  
재고기간 별 수량,금액 을 별도 테이블로 분리하는 것이 유리하다.

##3절 반정규화와 성능

- 반정규화란 ?

성능향상, 개방, 운영의 편리를 위하여 데이터 중복을 각오하고 테이블을 통합하는 것을 의미한다.  
단순히 JOIN이 귀찮아서 컬럼들을 통합하다가는 데이터의 무결성을 깨트리게 된다.  

####반정규화 적용방법

1. 반정규화 대상조사
  - 자주 사용되는 table에 range-scan을 하는 경우
  - 대량의 데이터가 있는 table에 range-scan을 하는 경우
  - 통계성 프로세스에서 통계정보를 필요로 할때 -> 별도의 통계테이블 생성 (반정규화)
  - 지나치게 많은 JOIN으로 조회 작업이 기술적으로 어려워 질때
2. 대안 검토 (반정규화가 아닌 다른 방법들)
  - 지나치게 많은 JOIN -> View 생성
  - 대량의 데이터 처리, 부분처리가 유리한 경우 -> 클러스터링 적용 또는 INDEX 조정 (단 DML이 적고 조회 위주의 테이블에만 효과적)
  - 대량의 데이터를 PK 성격에 따라 분리가 가능한 경우라면 -> 파티셔닝 기법 적용해서 물리적으로 분리
  - Application 로직을 변경하여 성능 개선
3. 반정규화 적용
  - 테이블 반정규화
  - 속성 반정규화
  - 관계 반정규화

####반정규화 기법
1. 테이블 반정규화
  - 테이블 병합 : 1:1 , 1:M , 슈퍼/서브타입 관계의 테이블들을 병합하여 성능향상
  - 테이블 분할
    - 수직분할 : 컬럼단위로 테이블을 1:1로 분리하여 트랜잭션을 분산 (트랜잭션의 유형이 선행되어야 함)
    - 수평분할 : row 단위로 테이블을 분리하여 트랜잭션을 분산
  - 테이블 추가
    - 중복테이블 추가 : 원격 등의 환경에서 서버가 다른 경우 동일한 테이블 중복생성
    - 통계테이블 추가 : 통계값을 미리 계산해 둠
    - 이력테이블 추가 : 마스터 테이블에 존재하는 레코드를 중복으로 이력테이블에 저장
    - 부분테이블 추가 : 자주 이용하는 집중화된 칼럼들을 모아놓은 별도 테이블 생성





