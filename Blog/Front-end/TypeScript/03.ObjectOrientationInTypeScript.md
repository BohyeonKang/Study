# Chapter 3 Object Orientation in TypeScript

소프트웨어를 디자인하는 방법 2가지가 있습니다.
하나는 간단하게 만들어서 명백하게 결함을 없게하는 것이고,
다른 방법은 복잡하게 만들어서 병백한 결함을 없게하는 것입니다.
전자가 조금 더 어렵습니다. 그것은 마치 복잡한 자연의 섭리와 같은 기술, 헌신, 통찰력, 영감 등을 요구합니다.
- Tony Hoare

객체지향 프로그래밍은 현실 세계와 유사하게 데이터와 관련된 행위를 코드로 표현합니다.
이것을 보통 property와 method를 포함하는 class로 표현하고 있으며,
해당 class로 부터 생성한 객체를 object라고 부릅니다.
....(이하 생략)

## Obejct Orientation in TypeScript

타입스크립트는 다양한 OOP 개념들을 지원하고 있습니다.

- Classes
- Instance of classes
- Methods
- Inheritance
- Open recursion
- Encapsulation
- Delegation
- Polumotphism

Calsses, Instace of classes, Methods, Ingeritacne는 Chapter.01에서 이미 살펴보았습니다.

## Open Recursion

연린 재귀(Open Recursion)은 재귀의 조합과 늦은 바인딩입니다.
클래스 내에서 메서드가 자기자신을 호출한 경우, 서브클래스에 정의된 함수를 호출 할 수도 있습니다.
*List 3-1*은 디렉토리의 내용을 읽는 클레스입니다.
`FileReader` 클래스는 입력받은 경로에서 내용들을 읽습니다.
모든 파일은 파일트리에 추가되지만, 디렉토리에 대해서는 `this.getFiles`를 재귀적으로 호출합니다.
이러한 재귀호출은 모든 하위 경로내의 파일들을 추가할때 까지 계속됩니다.
`fs.readdirSync`와 `fs.statSync` 메서드는 **NodeJS**에 있는 것으로 6장에서 자세히 설명드리겠습니다.

#### List 3-1 Open Recursion
```TypeScript
interface FileItem {
	path: string;
	contents: string[];
}

class FileReader
{
	getFiles(path: string, depth: number = 0)
	{
		var fileTree = [];
		var files = fs.readdirSync(path);
		
		for (var i = 0; i < files.length; i++)
		{
			var file = files[i];
			var stats = fs.statSync(file);
			var fileItem;
			if (stats.isDirectory())
			{
				// Add directory and contents
				fileItem = {
					path: file,
					contents: this.getFiles(file, (depth + 1))
				};
			} else {
				// Add file
				fileItem = {
					path: file,
					contents: []
				};
			}
			fileTree.push(fileItem);
		}
		
		return fileTree;
	}
}

class LimitedFileReader extends FileReader {
	
	constructor(public maxDepth: number)
	{
		super();
	}
	
	getFiles(path: string, depth = 0)
	{
		if (depth > this.maxDepth)
		{
			return [];
		}
		return super.getFiles(path, depth);
	}
}

// instatiating an instance of LimitedFileReader
var fileReader = new LimitedFileReader(1);
// results in only the top level, and one additional level being read
var files = fileReader.getFiles('path');
```

예제에서는 좀 더 간단하게 사용가능한 Sync 버전의 함수를 사용했지만,
실제로 구현할때에는 `readdir`, `stat`와 같이 콜백함수를 사용하는 것을 고려하는 것이 좋습니다.

`LimitedFileReader`는 `FieReader`의 서브클레스입니다.
`LimitedFileReader`의 인스턴스를 생성할 때 클레스에 표시ㅏ되는 파일 트리의 깊이를 지정해야 합니다.
이 예제에서는 `this.getFiles`를 열린재귀로 어떻게 호출하는가를 보여줍니다.
`FileReader`로 인스턴스를 생성한 경우 `this.getFiles`는 단순한 일반적인 재귀호출이 됩니다만,
`LimitedFileReader`로 인스턴스를 생성한 경우 `FileReader.getFiles` 메서드 내에서 `thid.getFiles`는 `LimitedFileReader.getFiles`를 호출하게 됩니다.

열린 재귀의 아름다운 점은 부모 클래스를 변경하지 할 필요도 없고, 서브클래스에 대한 사항을 몰라도 된다는 점입니다.
서브클래스는 부모클래스의 코드를 재사용하기 위해서 코드를 중복적으로 작성할 필요가 없습니다.