### 9.2 Interrupting threads

- long-running thread를 정지시키는데는 singnal로 처리하는 것이 좋습니다.
  - thread pool에 의해 동작중인 thread가 있는 상태에서 thread pool을 해제해야 할 경우
  - thread 동작을 사용자가 명시적으로 취소할 경우
  - 기타 다른 상황들에서 이런 작업이 필요한 경우가 있습니다.

- 어떤 상황이든 그 처리 방법은 같습니다.
  - thread의 처리가 원래대로 종료시점까지 실행되기 전에 signal을 보내서, 더 이상 실행되지 않고 빠져나오게 해야 합니다.

- 각각의 경우별로 구현을 해도 되지만, 우리 그러지 맙시다. 예 ?
  - thread 관련 구현은 의도대로 잘 되지 않을 경우가 많아서 제대로 돌아가는지 확인을 해야 합니다.
  - 하지만, 일반적인 메커니즘으로 구현하면, 한번만 검증을 제대로 마친 뒤 계속해서 믿고 쓸 수 있습니다.

- C++11에서 interrupting thread와 관련된 기능을 제공해주지는 않습니다.
  - 하지만 어렵지 않게 구현할 수 있습니다.
  - interrupting thread를 보기전에 먼저 thread의 시작 및 interrupt에 대한 interface 부터 살펴보기로 하겠습니다.

#### 9.2.1 Launching and interrupting another thread

- 우선 external interface부터 생각해 보겠습니다.
  - thread가 interrupt 가능하게 하기 위해서는 뭐가 필요할까요 ?
  - 당연히 std::thread 에 interrupt() 함수를 추가해야 합니다.

```C++
class interruptible_thread
{
public:
    template<typename FunctionType>
    interrputible_thread(FunctionType f);
    void join();
    void detach();
    bool joinable() const;
    void interrput();
};
```

- 기본적으로 std::thread를 이용하고, interruption handling에 일부만 구현하면 됩니다.
- thread 입장에서 뭐가 필요할까요 ?
  - `나(thread)는 여기서 interrupt 처리를 해도 된다.` 는 바로 그 interruption point가 중요합니다.
  - 다른 추가 정보 없이 (parameter 없이) 동작하는 함수 `interruption_point()` 을 추가해 보도록 하겠습니다.
  - thread의 상태를 저장하는 local 변수를 선언하여서 thread가 시작될 때 set 한 다음에 interruption_point() 함수에서 그 값을 제어하도록 구현 하면 됩니다.
- thread_local flag가 필요하기 때문에 일반적인 std::thread를 그대로 사용할 수 없습니다.
  - interruptible_thread를 제어하기 위해서는 이 변수가 필수적입니다.
  - std::thread가 시작되기전에 이 기능이 수행되도록 constuctor로 감싸야 합니다.

```C++
class interrupt_flag
{
public:
    void set();
    bool is_set() const;
};

thread_local interrupt_flag this_thread_interrupt_flag; // #1

class interruptible_thread
{
    std::thread internal_thread;
    interrupt_flag* flag;
public:
    template<typename FunctionType>
    interruptible_thread(FunctionType f)
    {
        std::promise<interrupt_flag*> p;               // #2
        internal_thread = std::thread([f, &p] {        // #3
                p.set_value(&this_thread_interrupt_flag);
                f();                                   // #4
            });
        flag = p.get_future().get();                   // #5
    }
    void interrupt()
    {
        if (flag)
        {
            flag->set();                               //#6
        }
    }
};
```

- 실제로 작업을 수행할 f 함수와 local promise 객체 p (#2) 를 감싼 lambda 식이 있습니다. (#3)
  - lambda식 안에서 promise의 값을 thread_local로 선언된 `this_thread_interrupt_flag` (#1)의 주소로 설정합니다.
  - 그렇게 set 한 다음에 새로운 thread를 할당하여 공급된 함수의 copy(사본)을 수행합니다. (#4)
- thread를 수행한 다음에 future와 연관된 promise가 준비되어서 그 결과를 flag라는 멤버변수에 줄때까지 기다립니다. (#5)
- lambda가 new thread를 수행중이고, 지역변수 p가 dangling reference라도 별 문제는 없습니다.
  - 왜냐하면 interruptible_thread의 생성자는 p가 더이상 실행하기 전의 new thread가 더이상 참조되지 않을때까지 기다립니다.
  - 이 구현은 thread의 join , detach 여부에 대해서 고려하지 않습니다.
  - thread가 종료되거나 detach 되었을 때 flag가 clear 되었는지만 확인하여 dangling pointer를 방지하면 됩니다.
- interrupt() 함수는 간단합니다.
  - interrupt flag에 대한 pointer를 가지고 있는 경우, interrupt 시킬 thread에 대해서 flag를 set하면 됩니다. (#6)

#### 9.2.2 Detecting that a thread has been interrupted

- 이제 interruption flag를 설정할 수 있게 되었습니다.
  - 다음으로는 thread가 실제로 중단되었는지 여부를 확인해 보도록 하겠습니다.
  - 가장 간단한 방법의 interruption_point() 함수를 사용하도록 하겠습니다.
    - thread 내의 interrupt되어도 안전한 곳에서 이 함수를 호출합니다.
    - flag가 설정된 경우라면 thread_interrupted 예외를 throw 하면 됩니다.

```C++
void interruption_point()
{
    if (this_thread_interrupt_flag.is_set())
        throw thread_interrupted();
}
```

사용은 이렇게 하면 됩니다.

```C++
void F()
{
    while(!done)
    {
        interruption_point();
        process_next_item();
    }
}
```

- 이것은 동작하는 code이긴 하지만, 이상적인 방법은 아닙니다.
  - thread를 interrupt하기 위한 최고의 장소중 하나는 thread가 interrupt_point()를 호출하기 위해 실행되고 있지 않는 것을 기다리면서 block된 상태이다.
  - interrupt 방식에 따라 뭔가를 기다리는 수단이 필요합니다. (?)

####9.2.3 Interrupting a condition variable wait

`interruption_point()`를 명시적으로 호출하여 원하는 곳에서 interruption을 감지할 수 있지만, 조건변수가 notify되기를 기다리는 것과 같은 blocking wait에서는 아무 도움이 되지 않습니다. wait할 수 있는 여러 가지 방법에 대해서 overload 가능하고, wait 작업을 중간 할 수 있는 새로운 `interruptible_wait()` 함수가 필요합니다.  
조건변수의 wait를 중단하게 하려면 어떻게 해야 할까요 ?  
가장 간단한 방법은 조건변수에 interrupt flag를 set 한 뒤 notify하고, wait 한 후 interrupt point를 넣는것입니다.  
하지만 이렇게 하면 필요한 thread를 깨우기 위해서 조건변수를 기다리는 wait 상태의 모든 thread에 notify해야 합니다.
결국 wait 중인 thread들은 모두 wake-up을 해야합니다. 비록 가짜 wake-up이지만, 그게 진짜 wake-up과 다를바가 없습니다.  
`interrupt_flag`는 `set()`이 호출될때 notify 될 수 있도록 조건변수의 포인터를 저장 할 수 있어야 합니다.
조건 변수에 대한 `interruptible_wait()`의 구현은 다음과 같습니다.

#####Listing 9.10 std::condition_variable 을 사용한 interruptible_wait (broken version)

```C++
void interruptible_wait(std::condition_variable& cv, std::uniduq_lock<std::mux>& lk)
{
    interruption_point();
    this_thread_interrupt_flag.set_condition_variable(cv);  // #1
    cv.wait(lk);                                            // #2
    this_thread_interrupt_falg.clear_condition_variable();  // #3
    interruption_point();
}
```

- interrupt flag 와 condition variable의 관계를 설정하고 해제하는 좋고 간단한 code 입니다.
  1. interrupt를 check.
  1. thread의 interrupt_flag와 condition_variable을 연결. #1
  1. condition_variable을 wait #2
  1. condition_variable의 연결 해제 #3
  1. interrupt를 다시 한번 check.
- condition_variable을 wait하는 동안 interrupt가 발생한 경우라면,
  - 해당 thread는 condition_variable을 통해서, wait 상태를 깨울 것입니다.
  - 그래서, interrupt의 확인이 가능합니다.
- 불행하게도, 이 code는 못씁니다. 2가지 문제가 있습니다.
  1. `std::condition_variable::wait()`에서 예외발생시 `interrupt_flag`와의 관계를 해제하지 않고 빠져나오게 됩니다.
    - destructor와 연결되는 구조를 활용하면 쉽게 고칠 수 있습니다.
  1. `race condition`(경쟁 조건)이 있습니다.
    - `interrupt_point()`와 `wait()` 사이에서 interrupt가 발생한 경우,
      - condition_variable는 interrupt_flag와의 관계에 대해서는 신경쓰지 않습니다.
        - 왜냐하면, thread는 wait 상태가 아니기 때문에 condition_variable을 notify 할 수 없습니다.
    - `interrupt_point()`와` wait()` 사이에서의 interrupt에 대한 notify 방안을 생각해야 합니다.
      - `std::condition_variable`의 내부 구현을 살펴보지 않고도 이 문제를 해결하는 방법은 딱 한가지밖에 없습니다.
        - `set_condition_variable()` 호출을 보호하는 용도의 mutex를 사용하는 것입니다.
    - 그런데, 이러면 또다른 문제가 발생합니다.
      - thread #2를 lock 시킬 다른 thread #1의 수명도 모른체 mutex의 참조를 통과시켜야 합니다. 
        - thread #1 : interrupt()를 호출하는 thread
        - thread #2 : interrupt 될 thread
      - thread #2가 이미 mutex를 lock 한지 그 여부도 모른체 위 작업을 해야 합니다.
        - `deadlock`의 가능성이과 이미 해제된 이후에 mutex에 접근할 가능성이 있습니다.
      - 조건변수의 wait를 interrupt 할수 없는 것은 너무 제한적이다.
        - `interruptible_wait()`를 안쓰고도 잘 할수는 있습니다.
        - 그래서 다른 대안이 있습니까 ?
          1. `wait_for()`를 사용하여 (1ms 같은) 작은 timeout value를 사용하는 것입니다. (`wait()`대신에)
            - thread가 `interruption`을 보기전에 wait 하는 시간의 상한선을 둡니다. 
            - 이렇게하면, 대기중인 thread는 오히려 더 많이 timeout으로 부터 `spurious wake`(가짜 wake)가 될 수 있지만, 쉽게 도움이 될수는 없습니다.
            - 이러한 구현을 `interrupt_flag`의 구현과 함께 보시겠습니다.

#####Listing 9.11 Using a timeout in interruptible_wait for std::condition_variable
```C++
class interrupt_flag
{
    std::atomic<bool> flag;
    std::condition_variable* thread_cond;
    std::mutex set_clear_mutex;
public:
    interrupt_flag()
        : thread_cond(0)
    {}
    
    void set()
    {
        flag.store(true,std::memory_order_relaxed);
        std::lock_guard<std::mutex> lk(set_clear_mutex);
        if(thread_cond)
        {
            thread_cond->notify_all();
        }
    }
    
    bool is_set() const
    {
        return flag.load(std::memory_order_relaxed);
    }
    
    void set_condition_variable(std::condition_variable& cv)
    {
        std::lock_guard<std::mutex> lk(set_clear_mutex);
        thread_cond=&cv;
    }
    
    void clear_condition_variable()
    {
        std::lock_guard<std::mutex> lk(set_clear_mutex);
        thread_cond=0;
    }
    
    struct clear_cv_on_destruct
    {
        ~clear_cv_on_destruct()
        {
            this_thread_interrupt_flag.clear_condition_variable();
        }
    };
};

void interruptible_wait(std::condition_variable& cv, std::unique_lock<std::mutex>& lk)
{
    interruption_point();
    this_thread_interrupt_flag.set_condition_variable(cv);
    interrupt_flag::clear_cv_on_destruct guard;
    interruption_point();
    cv.wait_for(lk,std::chrono::milliseconds(1));
    interruption_point();
}
```

만약 기다리고 있는 predicate이 있다면, 1ms timeout은 predicate loop 속으로 완벽하게 숨길 수 있습니다.

```C++
template<typename Predicate>
void interruptible_wait(std::condition_variable& cv,
                        std::unique_lock<std::mutex>& lk,
                        Predicate pred)
{
    interruption_point();
    this_thread_interrupt_flag.set_condition_variable(cv);
    interrupt_flag::clear_cv_on_destruct guard;
    while(!this_thread_interrupt_flag.is_set() && !pred())
    {
        cv.wait_for(lk,std::chrono::milliseconds(1));
    }
    interruption_point();
}
```

결과적으로 predicate가 더 자주 check하겠지만, 일반적인 wait() 호출보다는 더 쉽게 사용될 것입니다.
timeout을 이용한 여러가지 방법들은 구현이 쉽습니다. : 지정된 시간이나 1ms 라든지...
그래서 `std::condition_variable`의 wait가 `std::condition_variable_any`에 대해서 신경을 쓰고 있습니까 ?  
같거나 더 잘할수 있나요 ?

####9.2.4 Interrupting a wait on std::condition_variable_any

std::condition_variable_any differs from std::condition_variable in that it
works with any lock type rather than just std::unique_lock<std::mutex>. It turns out
that this makes things much easier, and you can do better with std::condition_
variable_any than you could with std::condition_variable. Because it works with
any lock type, you can build your own lock type that locks/unlocks both the internal
set_clear_mutex in your interrupt_flag and the lock supplied to the wait call, as
shown here.

#####Listing 9.12 interruptible_wait for std::condition_variable_any

```C++
class interrupt_flag
{
    std::atomic<bool> flag;
    std::condition_variable* thread_cond;
    std::condition_variable_any* thread_cond_any;
    std::mutex set_clear_mutex;
public:
    interrupt_flag()
        : thread_cond(0)
        , thread_cond_any(0)
    {}
    
    void set()
    {
        flag.store(true,std::memory_order_relaxed);
        std::lock_guard<std::mutex> lk(set_clear_mutex);
        if(thread_cond)
        {
            thread_cond->notify_all();
        }
        else if(thread_cond_any)
        {
            thread_cond_any->notify_all();
        }
    }
    
    template<typename Lockable>
    void wait(std::condition_variable_any& cv,Lockable& lk)
    {
        struct custom_lock
        {
            interrupt_flag* self;
            Lockable& lk;
            custom_lock(interrupt_flag* self_,
                        std::condition_variable_any& cond,
                        Lockable& lk_)
                : self(self_)
                , lk(lk_)
            {
                self->set_clear_mutex.lock(); //#1
                self->thread_cond_any=&cond; //#2
            }
            
            void unlock() //#3
            {
                lk.unlock();
                self->set_clear_mutex.unlock();
            }
            
            void lock()
            {
                std::lock(self->set_clear_mutex,lk); //#4
            }
            
            ~custom_lock()
            {
                self->thread_cond_any=0; //#5
                self->set_clear_mutex.unlock();
            }
        };
        
        custom_lock cl(this,cv,lk);
        interruption_point();
        cv.wait(cl);
        interruption_point();
    }
    // rest as before
};

template<typename Lockable>
void interruptible_wait(std::condition_variable_any& cv,
                        Lockable& lk)
{
    this_thread_interrupt_flag.wait(cv,lk);
}
```

Your custom lock type acquires the lock on the internal set_clear_mutex when it’s constructed
B and then sets the thread_cond_any pointer to refer to the std::condition_
variable_any passed in to the constructor c. The Lockable reference is stored for later;
this must already be locked. You can now check for an interruption without worrying
about races. If the interrupt flag is set at this point, it was set before you acquired the lock
on set_clear_mutex. When the condition variable calls your unlock() function inside
wait(),you unlock the Lockable object and the internal set_clear_mutex d. This allows
threads that are trying to interrupt you to acquire the lock on set_clear_mutex and
check the thread_cond_any pointer once you’re inside the wait() call but not before. This is
exactly what you were after (but couldn’t manage) with std::condition_variable. Once
wait() has finished waiting (either because it was notified or because of a spurious wake),
it will call your lock() function, which again acquires the lock on the internal
set_clear_mutex and the lock on the Lockable object e. You can now check again for
interruptions that happened during the wait() call before clearing the thread_cond_any
pointer in your custom_lock destructor f, where you also unlock the set_clear_mutex.

####9.2.5 Interrupting other blocking calls

That rounds up interrupting condition variable waits, but what about other blocking
waits: mutex locks, waiting for futures, and the like? In general you have to go for the
timeout option you used for std::condition_variable because there’s no way to
interrupt the wait short of actually fulfilling the condition being waited for, without
access to the internals of the mutex or future. But with those other things you do
know what you’re waiting for, so you can loop within the interruptible_wait() function.
As an example, here’s an overload of interruptible_wait() for a std::future<>:

```C++
template<typename T>
void interruptible_wait(std::future<T>& uf)
{
while(!this_thread_interrupt_flag.is_set())
{
if(uf.wait_for(lk,std::chrono::milliseconds(1)==
std::future_status::ready)
break;
}
interruption_point();
}
```

This waits until either the interrupt flag is set or the future is ready but does a blocking
wait on the future for 1 ms at a time. This means that on average it will be around 0.5 ms before an interrupt request is acknowledged, assuming a high-resolution clock.
The wait_for will typically wait at least a whole clock tick, so if your clock ticks every
15 ms, you’ll end up waiting around 15 ms rather than 1 ms. This may or may not be
acceptable, depending on the circumstances. You can always reduce the timeout if
necessary (and the clock supports it). The downside of reducing the timeout is that
the thread will wake more often to check the flag, and this will increase the taskswitching
overhead.
OK, so we’ve looked at how you might detect interruption, with the interruption_
point() and interruptible_wait() functions, but how do you handle that?

####9.2.6 Handling interruptions

From the point of view of the thread being interrupted, an interruption is just a
thread_interrupted exception, which can therefore be handled just like any other
exception. In particular, you can catch it in a standard catch block:

```C++
try
{
do_something();
}
catch(thread_interrupted&)
{
handle_interruption();
}
```

This means that you could catch the interruption, handle it in some way, and then
carry on regardless. If you do this, and another thread calls interrupt() again, your
thread will be interrupted again the next time it calls an interruption point. You might
want to do this if your thread is performing a series of independent tasks; interrupting
one task will cause that task to be abandoned, and the thread can then move on to
performing the next task in the list.
Because thread_interrupted is an exception, all the usual exception-safety precautions
must also be taken when calling code that can be interrupted, in order to
ensure that resources aren’t leaked, and your data structures are left in a coherent
state. Often, it will be desirable to let the interruption terminate the thread, so you
can just let the exception propagate up. But if you let exceptions propagate out of the
thread function passed to the std::thread constructor, std::terminate() will be
called, and the whole program will be terminated. In order to avoid having to
remember to put a catch (thread_interrupted) handler in every function you pass
to interruptible_thread, you can instead put that catch block inside the wrapper
you use for initializing the interrupt_flag. This makes it safe to allow the interruption
exception to propagate unhandled, because it will then terminate just that individual
thread. The initialization of the thread in the interruptible_thread constructor
now looks like this:

```C++
internal_thread=std::thread([f,&p]{
p.set_value(&this_thread_interrupt_flag);
try
{
f();
}
catch(thread_interrupted const&)
{}
});
```

Let’s now look at a concrete example where interruption is useful.

####9.2.7 Interrupting background tasks on application exit

Consider for a moment a desktop search application. As well as interacting with the
user, the application needs to monitor the state of the filesystem, identifying any
changes and updating its index. Such processing is typically left to a background
thread, in order to avoid affecting the responsiveness of the GUI. This background
thread needs to run for the entire lifetime of the application; it will be started as part of
the application initialization and left to run until the application is shut down. For such
an application this is typically only when the machine itself is being shut down, because
the application needs to run the whole time in order to maintain an up-to-date index. In
any case, when the application is being shut down, you need to close down the background
threads in an orderly manner; one way to do this is by interrupting them.
The following listing shows a sample implementation of the thread-management
parts of such a system.

#####Listing 9.13 Monitoring the filesystem in the background

```C++
std::mutex config_mutex;
std::vector<interruptible_thread> background_threads;
void background_thread(int disk_id)
{
while(true)
{
interruption_point(); //#1
fs_change fsc=get_fs_changes(disk_id); //#2
if(fsc.has_changes())
{
update_index(fsc); //#3
}
}
}
void start_background_processing()
{
background_threads.push_back(
interruptible_thread(background_thread,disk_1));
background_threads.push_back(
interruptible_thread(background_thread,disk_2));
}
int main()
{
start_background_processing(); //#4
process_gui_until_exit(); //#5
std::unique_lock<std::mutex> lk(config_mutex);
for(unsigned i=0;i<background_threads.size();++i)
{
background_threads[i].interrupt(); //#6
}
for(unsigned i=0;i<background_threads.size();++i)
{
background_threads[i].join(); //#7
}
}
```

At startup, the background threads are launched e. The main thread then proceeds
with handling the GUI f. When the user has requested that the application exit, the
background threads are interrupted g, and then the main thread waits for each background
thread to complete before exiting h. The background threads sit in a loop,
checking for disk changes c and updating the index d. Every time around the loop
they check for interruption by calling interruption_point() B.
Why do you interrupt all the threads before waiting for any? Why not interrupt
each and then wait for it before moving on to the next? The answer is concurrency.
Threads will likely not finish immediately when they’re interrupted, because they have
to proceed to the next interruption point and then run any destructor calls and
exception-handling code necessary before they exit. By joining with each thread
immediately, you therefore cause the interrupting thread to wait, even though it still has
useful work it could do—interrupt the other threads. Only when you have no more work
to do (all the threads have been interrupted) do you wait. This also allows all the
threads being interrupted to process their interruptions in parallel and potentially finish
sooner.
This interruption mechanism could easily be extended to add further interruptible
calls or to disable interruptions across a specific block of code, but this is left as an
exercise for the reader.

###9.3 Summary

In this chapter, we’ve looked at various “advanced” thread-management techniques:
thread pools and interrupting threads. You’ve seen how the use of local work queues
and work stealing can reduce the synchronization overhead and potentially improve
the throughput of the thread pool and how running other tasks from the queue while
waiting for a subtask to complete can eliminate the potential for deadlock.
We’ve also looked at various ways of allowing one thread to interrupt the processing
of another, such as the use of specific interruption points and functions that perform
what would otherwise be a blocking wait in a way that can be interrupted.
